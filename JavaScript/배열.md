# 배열

## 배열이란

여러 개의 값을 순차적으로 나열한 자료구조이다.
`배열 리터럴, Array 생성자 함수, Array from 메서드를 통해 생성할 수 있다.`
자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체이다.
배열이 가지고 있는 값을 요소라 하며 자바스크립트의 모든 값이 요소가 될 수 있고, 모든 요소는 0 이상의 정수인 인덱스를 가진다. 인덱스는 배열의 요소에 접근할 때 사용한다.

## 자바스크립트의 배열

일반적인 배열은 각 요소가 동일한 크기의 데이터를 가지며, 빈틈 없이 연속적으로 이어져 있다. 때문에 임의 접근할 수 있다. 하지만 자바스크립트의 배열은 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어지지 않은 배열을 희소 배열이라 한다.

### 일반적 배열과 자바스크립트 배열의 장단점

일반적 배열은 인덱스로 요소에 빠르게 접근 가능하다. 하지만 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적이 면에서 느릴 수밖에 없는 구조적 단점이 있다. 하지만 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

```
자바스크립트 배열은 인덱스로 배열 요소에 접근하는 경우에는 일반적인 배열보다 느리지만 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.
```

<p>

## Array 생성자 함수

```
const arr = new Array(10);
console.log(arr); // [empty * 10] (희소배열)
console.log(arr.length); // 10
```

```
new Array(); // -> []
```

전달된 인수가 2개 이상이거나, 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.

```
new Array(1); // -> [비어있음]
new Array(1,2,3); // -> [1,2,3]
new Array({}); // -> [{}]
```

Array 생성자 함수는 new 연산자와 함께 호출하지 않더라도(일반 함수로 호출해도) 배열을 생성하는 생성자 함수로 동작한다. Array 생성자 함수 내부에서 new.target을 확인하기 때문이다.

```
Array(1,2,3); // -> [1,2,3]
```

</p>

<p>

## Array.of

전달된 인수를 요소로 갖는 배열을 생성한다. 전달된 인수가 1개이고, 숫자여도 인수를 요소로 갖는 배열을 생성한다.

```
Array.of(1); // -> [1]
Array.of('string'); // -> ['string']
```

</p>

## Array.from

유사배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.

```
Array.from({length: 2, 0:'a', 1:'b'}); // -> ['a','b']
Array.from('Hi')// -> ['H','i']
```

두번째 인수로 콜백함수를 전달하면 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.

```
Array.from({length: 3}, (_, i) => i); // -> [0, 1, 2]
```

length만 존재하는 유사 배열 객체를 전달하며면 undefined 로 채운다.

```
Array.from({length: 3})
```

`유사배열 객체란, 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 유사 배열 객체는 마치 배열처럼 for 문으로 순회할 수도 있다.`

# 배열의 요소

## 배열의 인덱스

정수 이외의 값을 인덱스처럼 사용 하면 요소가 생성되는 것이 아니라, 프로퍼티가 생성된다. 이 때 추가된 프로퍼티는 length 프로퍼티 값에 영향을 주지 않는다.

## 배열 요소의 삭제

배열은 객체이기 때문에 특정요소 삭제를 위해 delete 연산자를 사용할 수 있다. 하지만 삭제 후 희소 배열이 만들어지며, length 프로퍼티 값은 변하지 않는다. 때문에 배열의 요소를 삭제할 때는 `delete 연산자 대신, splice 메서드를 사용하는 것이 좋다`.

# 배열 메서드

배열 메서드는 결과물을 반환하는 패턴이 두가지이다.

**원본 배열을 직접 변경하는 메서드**

- push
- pop
- unshift
- shift
- splice
- reverse
- fill

**원본 배열을 직접 변경하지 않고 새로운 배열을 생성하며 반환하는 메서드**

- slice

# 원본배열을 변경하지 않는 메서드

## **Array.indexOf**

원본 배열에서 인수로 전달된 요소를 검색하여 `인덱스 반환`한다.

- 일치하는 요소가 중복되면 첫번째 요소의 인덱스를 반환한다.
- 일치하는 요소가 없으면 -1을 반환한다.

## **Array.concat**

인수로 전달된 값을 원본 배열의 `마지막 요소로 추가한 새로운 배열`을 반환한다. 인수로 전달한 값이 배열인 경우, 배열을 해체해서 새로운 배열의 요소로 추가한다.

```
const arr = [1, 2];
let result = arr.concat(arr, 3);
console.log(result); // -> [1, 2, 3]
```

**push, unshift, concat 의 원본 배열 변경 여부 차이**

```
push와 unshift 메서드는 원본 배열을 직접 변경하지만 concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
- push와 unshift를 사용하는 경우 반드시 원본 배열을 변수에 따로 저장해두어야 한다
- concat 메서드를 사용하는 경우 반환값을 반드시 변수에 할당받아야 한다
```

**push, unshift, concat의 인수로 전달 받은 값이 배열인 경우 차이**

```
- push와 unshift 메서드는 배열을 그대로 원본 배열의 마지막/첫 요소로 추가한다
- concat 메서드는  인수로 전달받은 배열을 해체하여 배열의 마지막 요소로 추가한다
```

**push, unshift, concat 메서드 대신 스프레드 문법이 권장된다.**

## **Array.slice**

요소들을 복사하여 배열로 반환한다.

```
( 복사를 시작할 인덱스, 복사를 종료할 인덱스 )
```

인수를 모두 생략하면 원본 배열의 복사본을 생성하여 반환한다. 이때 생성된 복사본은 얕은 복사를 통해 생성된다.
**얕은 복사는 한 단계까지, 깉은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.**

# 원본 배열 직접 변경 메서드

## **Array.push**

전달받은 인수를 배열의 마지막 요소로 추가하고, `length를 반환`한다.
push를 사용하는 것보다, length 프로퍼티를 사용하여 직접 추가하는 것이 빠르다.

```
arr[arr.length] = 3; // 마지막 요소로 3 추가
```

원본 배열을 직접 변경하여 부수효과가 발생하므로, push 메서드 보다 스프레드 문법을 사용하여 요소를 추가하는 것이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 추가할 수 있으며, 부수 효과도 없다.

```
const arr = [3, 4];
const newArr = [...arr, 5]; // -> [3, 4, 5]
```

## **Array.pop**

원본 배열에서 마지막 요소를 제거하고, `제거한 요소를 반환`한다. 원본이 빈 배열이면 undefined를 반환한다.

## **Array.unshift**

인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 `length 프로퍼티 값을 반환`한다. push 메서드와 마찬가지로, 스프레드 문법을 대신 사용하면 함수 호출과 부수 효과 없이 추가할 수 있다.

```
const arr = [3, 4];
const newArr = [1, 2, ...arr]; // -> [1, 2, 3, 4]
```

## **Array.shift**

배열에서 첫번째 요소를 제거하고 `제거한 요소를 반환`한다. 원본 배열이 빈 배열이면 undefined를 반환한다.

## **Array.splice**

원본 배열의 중간에 요소를 추가하거나 제거하는 경우에 splice 를 사용한다. 세 개의 매개변수가 있다.

```
( 제거를 시작할 인덱스, 제거할 요소의 개수, 제거한 위치에 삽입할 요소의 목록 )
```

splice 메서드의 두 번째 인수(제거할 요소의 개수)를 0으로 지정하면 요소를 제거하지 않고 새로운 요소들을 삽입한다.

```
const arr = [1, 2, 3];
const result = arr.splice(1, 0, 100);
console.log(result); // [] (제거한 요소가 배열로 반환)
console.log(arr); // [1, 100, 2, 3]
```

# 배열 고차 함수

## **Array.prototype.sort**

## **Array.prototype.map**

## **Array.prototype.filter**

## **Array.prototype.reduce**

## **Array.prototype.some**

## **Array.prototype.every**

## **Array.prototype.findIndex**

## **Array.prototype.flatMap**
