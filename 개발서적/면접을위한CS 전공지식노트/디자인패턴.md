# 디자인 패턴

프로그램을 설계할 때 발생했던 문제들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것

## 싱글톤 패턴

하나의 클래스에 하나의 인스턴스를 만들어 이를 기반으로 로직을 만든다. 보통 데이터베이스 연결 모듈에 많이 쓰인다.

- 장점: 하나의 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스 생성 비용이 줄어듦

### 자바스크립트의 싱글톤패턴

간단한 예시로, 리터럴 또는 new Object로 객체를 생성하면 다른 어떤 객체와도 같지 않다.

자바스크립트의 싱글톤패턴 예시

```
class Singletone {
    constructor() {
        if(!Singletone.instance) {
            Singletone.instance = this
        }
    return Singletone.instance
    }

    getInstance() {
        return this.instance
    }
}
const a = new Singletone()
const b = new Singletone()
console.log(a === b) //true
```

Singletone.instance라는 하나의 인스턴스를 가지는 Singletone 클래스. a와 b는 하나의 인스턴스를 가진다.

### 데이터베이스 연결 모듈

다
class DB {
construnctor(url) {
if(!DB.instance) {
DB.instance = createConnection(url)
}
return DB.instance
}
connect() {
return this.instance
}
}

const a = new DB(URL)
const b = new DB(URL)
console.log(a === b) // true

```

DB.instance라는 하나의 인스턴스를 기반으로 a,b를 생성하였다. 이를 통해 데이터베이스 연결에 관한 인스턴스 생성비용을 아낄 수 있다.
</br>
싱글톤 패턴은 Node.js에서 MongoDB 데이터베이스를 연결할 때 Mongoose 모듈에서 볼 수 있다. mongoose의 데이터베이스를 연결할 때 쓰는 connect() 함수는 싱글톤 인스턴스를 반환한다. Node.js에서 MySQL데이터베이스를 연결할 때도 싱글톤 패턴이 쓰인다.

## 싱글톤 패턴의 단점

TDD(Test Driven Development)
TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 하는데 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다.
</br>
의존성 주입
싱글톤 패턴은 모듈 간 결합을 강하게 만들 수 있다. 이때 의존성 주입(DI, Dependency Injection)을 통해 모듈 간 결합을 느슨하게 하여 해결할 수 있다.

```

## 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴. 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.
상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 된다. 또, 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되니 유지 보수성이 증가된다.

## 전략 패턴(Strategy Pattern)

정책 패턴(Policy Pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다.

## 옵저버 패턴

주체(관찰자)가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴.

## 프록시 패턴과 프록시 서버

### 프록시 패턴

개상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴. 이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다. 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용된다.

```
프록시 서버에서의 캐싱
캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것. 이를 통해 불필요하게 외부와 연결하지 않아 트래픽을 줄일 수 있다는 장점이 있다.
```

### 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램.

## 이터레이터 패턴

이터레이터(iterator pattern)를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴. 순회할 수 있는 여러 가지 자료형의 구조와는 상관 없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.

## 노출 모듈 패턴(Revealing module pattern)

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴. 자바스크립트는 private나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행된다. 그렇기 때문에 노출모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 한다.

## MVC 패턴(Model, view, controller)

모델, 뷰, 컨트롤러로 이루어진 디자인 패턴. 어플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다. 재사용성과 확장성이 용이하다. 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있다.

### 모델

어플리케이션의 데이터인 데이터베이스, 상수, 변수 등

### 뷰

inputbox, checkbox, textarea 등 사용자 인터페이스 요소

### 컨트롤러

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 모델과 뷰의 생명 주기를 관리하며 모델이나 뷰의병경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려준다.

### **리액트**

리액트가 MVC 패턴을 이용한 대표적인 라이브러리이다. 가상 DOM을 통해 실제 DOM을 조작하는 것을 추상화 하여 성능을 높였다. 대표적인 특성으로 불변성이 있다. 예를 들어 state는 setState를 통해서만 수정이 가능하고 props를 기반으로 해서 만들어지는 컴포넌트인 pureComponent가 있다. 단방향 바인딩이 적용되어 있고, 자유도가 높다.

## MVP 패턴(Model, view, presenter)

뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴.

## MVVM 패턴(Model, view, view model)

뷰 모델은 뷰를 더 추상화한 계층이며 MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 게 특징이다. 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다.

### Vue.js

MVVM 패턴의 대표적인 프레임워크. 반응형이 특징인 프론트엔드 프레임워크. watch와 computed 등으로 쉽게 반응형적인 값들을 구축할 수 있다. 함수를 사용하지 않고 값 대입만으로도 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다는 점이 특징이다. 재사용 가능한 컴포넌트 기반으로 UI를 구축할 수 있으며 BMW, 구글, 루이비통 등에서 사용한다.
